package org.example;

import java_cup.runtime.*;
import java.util.Stack;

parser code {:

    public static Stack<Integer> scopeStack = new Stack<>();
    public static SymbolTable symbolTable;

    public Parser(Scanner scn, SymbolTable sym) {
        super(scn);
        symbolTable = sym;
        scopeStack.push(0);  // Global scope
    }

    private void handleError(String message, Symbol sym) {
        if (sym != null) {
            System.out.println("Error: " + message + " at line " + (sym.left + 1) + ", column " + sym.right);
        } else {
            System.out.println("Error: " + message);
        }
    }

    public void report_error(String message, Object info) {
        Symbol sym = (Symbol) info;
        handleError(message, sym);
    }

    public void syntax_error(Symbol cur_token) {
        handleError("Syntax error", cur_token);
        // Intentar recuperarse ignorando el token actual
        try {
            // Intentamos sincronizar con el siguiente token que tiene sentido
            // Buscar el siguiente símbolo válido y continuar la ejecución
            while (cur_token != null && cur_token.sym != sym.FIN_EXPRESION) {
                cur_token = this.getScanner().next_token(); // Avanza al siguiente token
            }
        } catch (Exception e) {
            handleError("Error de sincronización", null);
        }
    }

:}

/* Tokens */
terminal Integer ENTERO;
terminal Float FLOTANTE;
terminal Character CARACTER;
terminal String CADENA;
terminal Boolean BOOLEANO;
terminal COMA, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN;
terminal DOS_PUNTOS, SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;
terminal ASIGNACION, INCREMENTO, DECREMENTO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
terminal IGUAL, DIFERENTE, AND, OR, NOT, PRINT, CORCHETE_ABRE, CORCHETE_CIERRA;
terminal MAIN, READ, LIT_ENTERO, LIT_FLOTANTE, LIT_CADENA, LIT_CHAR, LIT_BOOL;
terminal LLAVE_ABRE, LLAVE_CIERRA, PARENTESIS_ABRE, PARENTESIS_CIERRA, FIN_EXPRESION;
terminal IDENTIFICADOR, ERROR;

/* Non-terminals */
non terminal Object program;
non terminal Object func_declarations, func_declaration, params_opt, param_list;
non terminal Object param, type, statement, statements;
non terminal Object var_declaration, assignment, array_declaration;
non terminal Object expression, arithmetic_expr, array_access;
non terminal Object relational_expr, logical_expr;
non terminal Object if_statement, else_opt, while_statement, for_statement;
non terminal Object switch_statement, cases, case_statement, default_opt;
non terminal Object for_initialization, for_update, opt_expression;
non terminal Object io_statement, element_list, opt_equals_value;
non terminal Object literal, error_nterm, function_call, arg_list;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NOT;
precedence right INCREMENTO, DECREMENTO;

/* Grammar rules */

program ::= func_declarations:f MAIN LLAVE_ABRE statements:s LLAVE_CIERRA
          | MAIN LLAVE_ABRE statements:s LLAVE_CIERRA
          ;

func_declarations ::= func_declaration:f func_declarations:fs
                   | func_declaration:f
                   ;

func_declaration ::= type:t IDENTIFICADOR:i PARENTESIS_ABRE params_opt:p PARENTESIS_CIERRA LLAVE_ABRE {:
    scopeStack.push(scopeStack.peek() + 1);  // Nuevo scope para la función
:} statements:s LLAVE_CIERRA {:
    scopeStack.pop();  // Regresar al scope anterior
:}
                  ;

type ::= ENTERO
       | FLOTANTE
       | BOOLEANO
       | CARACTER
       | CADENA
       ;

params_opt ::= param_list:p
             | /* empty */
             ;

param_list ::= param:p COMA param_list:pl
             | param:p
             ;

param ::= type:t IDENTIFICADOR:i {:
        symbolTable.addSymbol(i.toString(), (t == null) ? "parametro" : t.toString(), scopeStack.peek(), ileft, iright);
:}
        ;

statements ::= statement:s statements:ss
             | /* empty */
             ;

statement ::= var_declaration:v FIN_EXPRESION
            | assignment:a  FIN_EXPRESION
            | array_declaration:ad FIN_EXPRESION
            | if_statement:i
            | while_statement:w
            | for_statement:f
            | switch_statement:sw
            | io_statement:io FIN_EXPRESION
            | function_call:fc
            | RETURN opt_expression:e FIN_EXPRESION
            | BREAK FIN_EXPRESION
            | error_nterm:e
            ;

function_call ::= IDENTIFICADOR:i PARENTESIS_ABRE arg_list:args PARENTESIS_CIERRA
                ;

arg_list ::= /* empty */
           | expression:a COMA arg_list:al
           | expression:a
           ;

array_declaration ::= type:t IDENTIFICADOR:i CORCHETE_ABRE CORCHETE_CIERRA ASIGNACION LLAVE_ABRE element_list:el LLAVE_CIERRA
                    | type:t IDENTIFICADOR:i CORCHETE_ABRE expression:e CORCHETE_CIERRA
                    ;

element_list ::= expression:e COMA element_list:el
               | expression:e
               ;

opt_equals_value ::= ASIGNACION expression | /* empty */ ;

var_declaration ::= type:t IDENTIFICADOR:i opt_equals_value
                    {:
                        symbolTable.addSymbol(i.toString(), (t == null) ? "Variable" : t.toString(), scopeStack.peek(), ileft, iright);
                    :}
                    ;

assignment ::= IDENTIFICADOR:i ASIGNACION expression:e
               ;

opt_expression ::= /* empty */
                 | expression;


expression ::= arithmetic_expr:a
             | relational_expr:r
             | logical_expr:l
             | literal:l
             | IDENTIFICADOR:i
             | PARENTESIS_ABRE expression:e PARENTESIS_CIERRA
             | CORCHETE_ABRE expression:e CORCHETE_CIERRA
             | array_access
             | function_call
             ;

array_access ::= IDENTIFICADOR:i CORCHETE_ABRE expression:e CORCHETE_CIERRA
               ;

literal ::= LIT_ENTERO
          | LIT_FLOTANTE
          | LIT_CADENA
          | LIT_CHAR
          | LIT_BOOL
          ;

arithmetic_expr ::= expression:e1 SUMA expression:e2
                 | expression:e1 RESTA expression:e2
                 | expression:e1 MULTIPLICACION expression:e2
                 | expression:e1 DIVISION expression:e2
                 | expression:e1 MODULO expression:e2
                 | expression:e1 POTENCIA expression:e2
                 | RESTA expression:e
                 | expression:e INCREMENTO
                 | expression:e DECREMENTO
                 | DECREMENTO expression:e
                 | INCREMENTO expression:e
                 ;

relational_expr ::= expression:e1 MENOR expression:e2
                 | expression:e1 MENOR_IGUAL expression:e2
                 | expression:e1 MAYOR expression:e2
                 | expression:e1 MAYOR_IGUAL expression:e2
                 | expression:e1 IGUAL expression:e2
                 | expression:e1 DIFERENTE expression:e2
                 ;

logical_expr ::= expression:e1 AND expression:e2
               | expression:e1 OR expression:e2
               | NOT expression:e
               ;

if_statement ::= IF PARENTESIS_ABRE expression:e PARENTESIS_CIERRA LLAVE_ABRE {:
    scopeStack.push(scopeStack.peek() + 1);  // Nuevo scope para el bloque if
:} statements:s LLAVE_CIERRA else_opt:eo {:
    scopeStack.pop();  // Regresar al scope anterior
:}
               ;

else_opt ::= ELSE LLAVE_ABRE {:
    scopeStack.push(scopeStack.peek() + 1);  // Nuevo scope para el bloque else
:} statements:s LLAVE_CIERRA {:
    scopeStack.pop();  // Regresar al scope anterior
:}
           | /* empty */
           ;

while_statement ::= WHILE PARENTESIS_ABRE expression:e PARENTESIS_CIERRA LLAVE_ABRE {:
    scopeStack.push(scopeStack.peek() + 1);  // Nuevo scope para el bloque while
:} statements:s LLAVE_CIERRA {:
    scopeStack.pop();  // Regresar al scope anterior
:}
                 ;

for_statement ::= FOR PARENTESIS_ABRE for_initialization:fi FIN_EXPRESION opt_expression:c FIN_EXPRESION for_update:fu PARENTESIS_CIERRA LLAVE_ABRE statements:bloque LLAVE_CIERRA
                ;

for_initialization ::= assignment
                     | var_declaration
                     | /* empty */;

for_update ::= assignment
             | arithmetic_expr:e
             | /* empty */;


switch_statement ::= SWITCH PARENTESIS_ABRE expression:e PARENTESIS_CIERRA LLAVE_ABRE {:
    scopeStack.push(scopeStack.peek() + 1);  // Nuevo scope para el bloque switch
:} cases:c default_opt:dfo LLAVE_CIERRA {:
    scopeStack.pop();  // Regresar al scope anterior
:}
                     ;

cases ::= case_statement:c cases:cs
        | /* empty */
        ;

case_statement ::= CASE literal:l DOS_PUNTOS statements:s
                 ;

default_opt ::= DEFAULT DOS_PUNTOS statements:s
              | /* empty */
              ;

io_statement ::= PRINT PARENTESIS_ABRE expression:e PARENTESIS_CIERRA
               | READ PARENTESIS_ABRE IDENTIFICADOR:i PARENTESIS_CIERRA
               ;

error_nterm ::= ERROR {: handleError("Error encontrado", null); :}
          ;
